<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    >

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:fontFamily="serif"
        android:textStyle="bold"
        android:text="Understanding Ownership"
        android:textColor="@color/black"
        android:textSize="35dp"
        android:id="@+id/headingch4"/>


    <ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fillViewport="true"
        android:layout_below="@id/headingch4">

        <LinearLayout
            android:layout_margin="4dp"
            android:orientation="vertical"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">



            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:id="@+id/tfc2"
                android:text="   Ownership is Rust’s most unique feature, and it enables Rust to make memory safety guarantees without needing a garbage collector. Therefore, it’s important to understand how ownership works in Rust. In this chapter, we’ll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory."/>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="What is Ownership"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   Rust’s central feature is ownership. Although the feature is straightforward to explain, it has deep implications for the rest of the language.
All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.
Because ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the more you’ll be able to naturally develop code that is safe and efficient. Keep at it!
When you understand ownership, you’ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you’ll learn ownership by working through some examples that focus on a very common data structure: strings."/>



            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Ownership Rules"/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   First, let’s take a look at the ownership rules. Keep these rules in mind as we work through the examples that illustrate them:

Each value in Rust has a variable that’s called its owner.
There can only be one owner at a time.
When the owner goes out of scope, the value will be dropped."/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Variable Scope"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:justificationMode="inter_word"
                android:textSize="23sp"
                android:textColor="@color/black"
                android:text="   We’ve walked through an example of a Rust program already in Chapter 2. Now that we’re past basic syntax, we won’t include all the fn main() { code in examples, so if you’re following along, you’ll have to put the following examples inside a main function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code. In other words, there are two important points in time here:
When s comes into scope, it is valid.
It remains valid until it goes out of scope.
At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we’ll build on top of this understanding by introducing the String type"
                />

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="The String Type"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the “Data Types” section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.
We’ll use String as the example here and concentrate on the parts of String that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We’ll discuss String in more depth in Chapter 8.
We’ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren’t suitable for every situation in which we may want to use text. One reason is that they’re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, String. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a String from a string literal using the from function"/>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Memory and Allocation"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   n the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal’s immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.
With the String type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:
The memory must be requested from the memory allocator at runtime.
We need a way of returning this memory to the allocator when we’re done with our String.
That first part is done by us: when we call String::from, its implementation requests the memory it needs. This is pretty much universal in programming languages.
However, the second part is different. In languages with a garbage collector (GC), the GC keeps track and cleans up memory that isn’t being used anymore, and we don’t need to think about it. Without a GC, it’s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one allocate with exactly one free.
Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope."/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="References and Borrowing"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   The issue with the tuple code in Listing 4-5 is that we have to return the String to the calling function so we can still use the String after the call to calculate_length, because the String was moved into calculate_length."/>

            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Mutable Refference"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   his restriction allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with, because most languages let you mutate whenever you’d like.

The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:

Two or more pointers access the same data at the same time.
At least one of the pointers is being used to write to the data.
There’s no mechanism being used to synchronize access to the data.
Data races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime; Rust prevents this problem from happening because it won’t even compile code with data races!"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Dangling Refference"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Comments"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   In languages with pointers, it’s easy to erroneously create a dangling pointer, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does."/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   Rules:Let’s recap what we’ve discussed about references:

At any given time, you can have either one mutable reference or any number of immutable references.
References must always be valid.
Next, we’ll look at a different kind of reference: slices.
"/>



            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="The Slice Type"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   Another data type that does not have ownership is the slice. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.We’ll discuss iterators in more detail in Chapter 13. For now, know that iter is a method that returns each element in a collection and that enumerate wraps the result of iter and returns each element as part of a tuple instead. The first element of the tuple returned from enumerate is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.Because the enumerate method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust. So in the for loop, we specify a pattern that has i for the index in the tuple and ampersand item for the single byte in the tuple. Because we get a reference to the element from .iter().enumerate(), we use ampersand in the pattern.
Inside the for loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using s.len().We now have a way to find out the index of the end of the first word in the string, but there’s a problem. We’re returning a usize on its own, but it’s only a meaningful number in the context of the ampersand String. In other words, because it’s a separate value from the String, there’s no guarantee that it will still be valid in the future. Now we’re tracking a starting and an ending index, and we have even more values that were calculated from data in a particular state but aren’t tied to that state at all. We now have three unrelated variables floating around that need to be kept in sync.We can create slices using a range within brackets by specifying [starting_index..ending_index], where starting_index is the first position in the slice and ending_index is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to ending_index minus starting_index. So in the case of let world = ampersand s[6..11];, world would be a slice that contains a pointer to the 7th byte (counting from 1) of s with a length value of 5. We now have a straightforward API that’s much harder to mess up, because the compiler will ensure the references into the String remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn’t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner."/>


            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="25sp"
                android:fontFamily="serif"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="Summary"/>
            <TextView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:textSize="23sp"
                android:justificationMode="inter_word"
                android:textColor="@color/black"
                android:text="   The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control. Ownership affects how lots of other parts of Rust work, so we’ll talk about these concepts further throughout the rest of the book. Let’s move on to Chapter 5 and look at grouping pieces of data together in a struct."/>


        </LinearLayout>

    </ScrollView>


</RelativeLayout>